.\"t
.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "FMUL\- Fractional Multiply Unsigned \- \- AVR Assembler" "" "" "" ""
.hy
.SH AVR Assembler Instructions
.SS FMUL \- Fractional Multiply Unsigned
.SS  () Description:
.PP
This instruction performs 8\-bit × 8\-bit → 16\-bit unsigned
multiplication and shifts the result one bit left.
.PP
Rd
.PP
Rr
.PP
R1
.PP
R0
.PP
Multiplicand
.PP
×
.PP
Multiplier
.PP
\->
.PP
Product High
.PP
Product Low
.PP
8
.PP
8
.PP
16
.PP
Let (N.Q) denote a fractional number with N binary digits left of the
radix point, and Q binary digits right of the radix point.
A multiplication between two numbers in the formats (N1.Q1) and (N2.Q2)
results in the format ((N1+N2).(Q1+Q2)).
For signal processing applications, the format (1.7) is widely used for
the inputs, resulting in a (2.14) format for the product.
A left shift is required for the high byte of the product to be in the
same format as the inputs.
The FMUL instruction incorporates the shift operation in the same number
of cycles as MUL.
.PP
The (1.7) format is most commonly used with signed numbers, while FMUL
performs an unsigned multiplication.
This instruction is therefore most useful for calculating one of the
partial products when performing a signed multiplication with 16\-bit
inputs in the (1.15) format, yielding a result in the (1.31) format.
Note: the result of the FMUL operation may suffer from a 2's complement
overflow if interpreted as a number in the (1.15) format.
The MSB of the multiplication before shifting must be taken into
account, and is found in the carry bit.
See the following example.
.PP
The multiplicand Rd and the multiplier Rr are two registers containing
unsigned fractional numbers where the implicit radix point lies between
bit 6 and bit 7.
The 16\-bit unsigned fractional product with the implicit radix point
between bit 14 and bit 15 is placed in R1 (high byte) and R0 (low byte).
.PP
This instruction is not available in all devices.
Refer to the device specific instruction set summary.
.PP
Operation:
.PP
R1:R0 ← Rd × Rr(unsigned (1.15) ← unsigned (1.7) × unsigned (1.7))
.PP
Syntax: Operands: Program Counter:
.PP
FMUL Rd,Rr 16 ≤ d ≤ 23, 16≤ r ≤ 23 PC ← PC + 1
.PP
16\-bit Opcode:
.PP
.TS
tab(@);
l l l l.
T{
.PP
0000
T}@T{
.PP
0011
T}@T{
.PP
0ddd
T}@T{
.PP
1rrr
T}
.TE
.SS  () Status Register (SREG) and Boolean Formula:
.PP
.TS
tab(@);
l l l l l l l l.
T{
.PP
I
T}@T{
.PP
T
T}@T{
.PP
H
T}@T{
.PP
S
T}@T{
.PP
V
T}@T{
.PP
N
T}@T{
.PP
Z
T}@T{
.PP
C
T}
_
T{
.PP
\-
T}@T{
.PP
\-
T}@T{
.PP
\-
T}@T{
.PP
\-
T}@T{
.PP
\-
T}@T{
.PP
\-
T}@T{
.PP
⇔
T}@T{
.PP
⇔
T}
.TE
.PP
C: R16
.PP
Set if bit 15 of the result before left shift is set; cleared otherwise.
.PP
Z:
$\\overline{R15} \\overline{R14} \\overline{R13} \\overline{R12}$
.PP
$\\overline{R11} \\overline{R10} \\overline{R9} \\overline{R8}$
.PP
$\\overline{R7} \\overline{R6} \\overline{R5} \\overline{R4}$
.PP
$\\overline{R3} \\overline{R2} \\overline{R1} \\overline{R0}$
.PP
.PP
Set if the result is $0000; cleared otherwise.
.PP
R (Result) equals R1,R0 after the operation.
.PP
Example:
.IP
.nf
\f[C]
\ ;******************************************************************************
;*\ DESCRIPTION
;*Signed\ fractional\ multiply\ of\ two\ 16\-bit\ numbers\ with\ 32\-bit\ result.
;*\ USAGE
;*r19:r18:r17:r16\ =\ (\ r23:r22\ *\ r21:r20\ )\ <<\ 1
\ ;******************************************************************************
fmuls16x16_32:\ clr\ r2
fmuls\ r23,\ r21\ ;((signed)ah\ *\ (signed)bh)\ <<\ 1
movw\ r19:r18,\ r1:r0
fmul\ r22,\ r20\ ;(al\ *\ bl)\ <<\ 1
adc\ r18,\ r2
movw\ r17:r16,\ r1:r0
fmulsu\ r23,\ r20\ ;((signed)ah\ *\ bl)\ <<\ 1
sbc\ r19,\ r2
add\ r17,\ r0
adc\ r18,\ r1
adc\ r19,\ r2
fmulsu\ r21,\ r22\ ;((signed)bh\ *\ al)\ <<\ 1
sbc\ r19,\ r2
add\ r17,\ r0
adc\ r18,\ r1
adc\ r19,\ r2
\f[]
.fi
.PP
.PP
Words: 1 (2 bytes)
.PP
Cycles: 2
