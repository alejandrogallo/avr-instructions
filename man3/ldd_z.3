.\"t
.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "LD (LDD) \- Load Indirect From data space to Register using Index Z \-
\- AVR Assembler" "" "" "" ""
.hy
.SH AVR Assembler Instructions
.SS LD (LDD) \- Load Indirect From data space to Register using Index Z
.SS Description:
.PP
Loads one byte indirect with or without displacement from the data space
to a register.
For parts with SRAM, the data space consists of the register file, I/O
memory and internal SRAM (and external SRAM if applicable).
For parts without SRAM, the data space consists of the register file
only.
The EEPROM has a separate address space.
.PP
The data location is pointed to by the Z (16 bits) pointer register in
the register file.
Memory access is limited to the current data segment of 64K bytes.
To access another data segment in devices with more than 64K bytes data
space, the RAMPX, RAMPY,
RAMPZ (avrassembler.wb_registers.html#avrassembler.RAMPX__RAMPY__RAMPZ)
in register in the I/O area has to be changed.
.PP
The Z pointer register can either be left unchanged by the operation, or
it can be post\-incremented or pre\-decremented.
These features are especially suited for stack pointer usage of the Z
pointer register, however because the Z pointer register can be used for
indirect subroutine calls, indirect jumps and table lookup, it is often
more convenient to use the X or Y pointer as a dedicated stack pointer.
Note that only the low byte of the Z pointer is updated in devices with
no more than 256 bytes data space.
For such devices, the high byte of the pointer is not used by this
instruction and can be used for other purposes.
The RAMPX, RAMPY,
RAMPZ (avrassembler.wb_registers.html#avrassembler.RAMPX__RAMPY__RAMPZ)
register in the I/O area is updated in parts with more than 64K bytes
data space or more than 64K bytes program memory, and the
increment/decrement/displacement is added to the entire 24\-bit address
on such devices.
.PP
Not all variants of this instruction is available in all devices.
Refer to the device specific instruction set summary.
.PP
For using the Z pointer for table lookup in program memory see the
LPM (avrassembler.wb_LPM.html) and ELPM (avrassembler.wb_ELPM.html)
instructions.
.PP
The result of these combinations is undefined:
.PP
LD r30, Z+
.PP
LD r31, Z+
.PP
LD r30, \-Z
.PP
LD r31, \-Z
.PP
Using the Z pointer:
.PP
Operation: Comment:
.PP
(i) Rd ← (Z) Z: Unchanged
.PP
(ii) Rd ← (Z) Z ← Z + 1Z: Post increment
.PP
(iii) Z ← Z \-1 Rd ← (Z) Z: Pre decrement
.PP
(iiii)* Rd ← (Z+q) Z: Unchanged, q: Displacement
.PP
Syntax: Operands: Program Counter:
.PP
(i) LD Rd, Z 0 ≤ d ≤ 31 PC ← PC + 1
.PP
(ii) LD Rd, Z+ 0 ≤ d ≤ 31 PC ← PC + 1
.PP
(iii) LD Rd, \-Z 0 ≤ d ≤ 31 PC ← PC + 1
.PP
(iiii)* LDD Rd, Z+q 0 ≤ d ≤ 31, 0 ≤ q ≤ 63 PC ← PC + 1
.PP
Notes:
.PP
*)The displacement form of this instruction (LDD) is not available on
AVR8L based devices.
.PP
16\-bit Opcode:
.PP
.TS
tab(@);
l l l l l.
T{
.PP
(i)
T}@T{
.PP
1000
T}@T{
.PP
000d
T}@T{
.PP
dddd
T}@T{
.PP
0000
T}
_
T{
.PP
(ii)
T}@T{
.PP
1001
T}@T{
.PP
000d
T}@T{
.PP
dddd
T}@T{
.PP
0001
T}
T{
.PP
(iii)
T}@T{
.PP
1001
T}@T{
.PP
000d
T}@T{
.PP
dddd
T}@T{
.PP
0010
T}
T{
.PP
(iiii)
T}@T{
.PP
10q0
T}@T{
.PP
qq0d
T}@T{
.PP
dddd
T}@T{
.PP
0qqq
T}
.TE
.SS Status Register (SREG) and Boolean Formula:
.PP
.TS
tab(@);
l l l l l l l l.
T{
.PP
I
T}@T{
.PP
T
T}@T{
.PP
H
T}@T{
.PP
S
T}@T{
.PP
V
T}@T{
.PP
N
T}@T{
.PP
Z
T}@T{
.PP
C
T}
_
T{
.PP
\-
T}@T{
.PP
\-
T}@T{
.PP
\-
T}@T{
.PP
\-
T}@T{
.PP
\-
T}@T{
.PP
\-
T}@T{
.PP
\-
T}@T{
.PP
\-
T}
.TE
.PP
Example:
.IP
.nf
\f[C]
clr\ r31\ ;\ Clear\ Z\ high\ byte
ldi\ r30,$60\ ;\ Set\ Z\ low\ byte\ to\ $60
ld\ r0,Z+\ ;\ Load\ r0\ with\ data\ space\ loc.\ $60(Z\ post\ inc)
ld\ r1,Z\ ;\ Load\ r1\ with\ data\ space\ loc.\ $61
ldi\ r30,$63\ ;\ Set\ Z\ low\ byte\ to\ $63
ld\ r2,Z\ ;\ Load\ r2\ with\ data\ space\ loc.\ $63
ld\ r3,\-Z\ ;\ Load\ r3\ with\ data\ space\ loc.\ $62(Z\ pre\ dec)
ldd\ r4,Z+2\ ;\ Load\ r4\ with\ data\ space\ loc.\ $64
\f[]
.fi
.PP
.PP
Words:1 (2 bytes)
.PP
Cycles:
.PP
.TS
tab(@);
l l l l.
T{
T}@T{
.PP
Cycles
T}@T{
.PP
Cycles xmega
T}@T{
.PP
Cycles AVR8L
T}
_
T{
.PP
(i)
T}@T{
.PP
2
T}@T{
.PP
1/2*
T}@T{
.PP
1/2**
T}
T{
.PP
(ii)
T}@T{
.PP
2
T}@T{
.PP
1/2*
T}@T{
.PP
1/2**
T}
T{
.PP
(iii)
T}@T{
.PP
2
T}@T{
.PP
2/3*
T}@T{
.PP
2/3**
T}
T{
.PP
(iiii)
T}@T{
.PP
2
T}@T{
.PP
2/3*
T}@T{
.PP
N/A
T}
.TE
.PP
(*) When accessing internal SRAM, one extra cycle is required (**) When
accessing FLASH, one extra cycle is required.
