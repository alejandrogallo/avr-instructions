.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "AVR Assembler Known Issues \- \- AVR Assembler" "" "" "" ""
.hy
.SH AVR Assembler AVR Assembler Known Issues
.IP \[bu] 2
Line continuation doesn't work in macro
calls (avrassembler.wb_Known_Issues.html#avrassembler.wb_Known_Issues.Issue_4146)
.IP \[bu] 2
Missing newline at end of
file (avrassembler.wb_Known_Issues.html#avrassembler.wb_Known_Issues.Missing_newline_at_end_of_file)
.IP \[bu] 2
Increment/decrement
operators (avrassembler.wb_Known_Issues.html#avrassembler.wb_Known_Issues.decrement)
.IP \[bu] 2
Forward references in
conditionals (avrassembler.wb_Known_Issues.html#avrassembler.wb_Known_Issues.Forward_references)
.IP \[bu] 2
Error
messages (avrassembler.wb_Known_Issues.html#avrassembler.wb_Known_Issues.Error_messages)
.IP \[bu] 2
defined (avrassembler.wb_Known_Issues.html#avrassembler.wb_Known_Issues.defined)
.IP \[bu] 2
Preprocessor
issues (avrassembler.wb_Known_Issues.html#avrassembler.wb_Known_Issues.Preprocessor_issues)
.SS Issue #4146: Line continuation doesn't work in macro calls
.PP
The following program illustrates this issue.
.PP
.IP
.nf
\f[C]
\&.macro\ m\ 
ldi\ \@0,\ \@1\ 
\&.endm\ m\ r16,\\\ 0
\f[]
.fi
.PP
.PP
This is not a problem with preprocessor macros (
\f[C]\ \ \ \ \ \ \ #define\ \ \ \ \ \ \f[] ).
.SS Missing newline at end of file
.PP
AVRASM2 has some issues if the last line in a source file is missing a
newline: Error messages may refer to wrong filename/line number if the
error is in the last line of a included files, and in some cases syntax
errors may result.
Beware that the Atmel Studio editor will not append a missing newline at
the end of a source file automatically.
.SS Increment/decrement operators
.PP
Increment/decrement operators (++/\[en]) are recognized by the assembler
and may cause surprises, e.g.
symbol\[en]1 will cause a syntax error, writesymbol \- \-1 if that is
what is intended.
This behaviour is consistent with C compilers.
The ++/\[en] operators are not useful in the current assembler, but are
reserved for future use.
.SS Forward references in conditionals
.PP
Using a forward reference in an assembler conditional may cause
surprises, and in some cases is not allowed.
Example:
.IP
.nf
\f[C]
\&.org\ LARGEBOOTSTART
;\ the\ following\ sets\ up\ RAMPZ:Z\ to\ point\ to\ a\ FLASH\ data\ object,\ typically
;\ for\ use\ with\ ELPM.
\ \ \ \ \ \ \ \ 
ldi\ ZL,\ low\ (cmdtable\ *\ 2)
\ \ \ \ \ \ \ \ 
ldi\ ZH,\ high\ (cmdtable\ *\ 2)
\&.if\ ((cmdtable\ *\ 2)\ >\ 65535)
\ \ \ \ \ \ \ \ 
ldi\ r16,\ 1
\ \ \ \ \ \ \ \ 
sts\ RAMPZ,\ r16
\&.endif
\ \ \ \ \ \ \ \ 
;\ more\ code\ follows\ here
cmdtable:\ .db\ "foo",\ 0x0
\f[]
.fi
.PP
The reason for this is that the outcome of the conditional will
influence the value of the forward referenced label, which in turn may
affect the outcome of the conditional, and so on.
.PP
The following is allowed:
.PP
.IP
.nf
\f[C]
\&.ifdef\ FOO\ 
nop\ ;\ some\ code\ here\ 
\&.endif\ 
rjmp\ label\ ;\ more\ code\ here\ 
\&.equ\ FOO\ =\ 100\ 
label:\ nop
\f[]
.fi
.PP
.PP
In this example FOO is not defined at the point it is used in a
conditional.
The use of .ifdef in this situation is allowed, and the conditional is
false.
However, the pattern shown above is not recommended because the
programmer's intention is not clear.
The form is intended to allow common constructs like this:
.PP
.IP
.nf
\f[C]
;\ Define\ FOO\ if\ it\ is\ not\ already\ defined.\ 
\&.ifndef\ FOO\ 
\&.equ\ FOO\ =\ 0x100\ 
\&.endif
\f[]
.fi
.PP
.PP
Up to and including AVRASM 2.0.30, these situations were not always
properly detected, causing incomprehensible error messages.
Starting with 2.0.31, explicit error messages are given.
.PP
Note that with preprocessor conditionals (
\f[C]\ \ \ \ \ \ \ #if/#ifdef\ \ \ \ \ \ \f[] ), the situation is always
well\-defined, preprocessor symbols are always undefined until the
definition is seen.
and this kind of error will never occur.
.SS Error messages
.PP
Sometimes error messages may be hard to understand.
Typically, a simple typo in some instances may produce error messages
like this:
.PP
\f[C]\ \ \ \ \ \ \ myfile.asm(30):\ error:\ syntax\ error,\ unexpected\ \ \ FOO\ \ \ \ \ \ \f[]
.PP
where FOO represents some incomprehensible gibberish.
The referenced filename/line number is correct, however.
.SS defined incorrectly treated as an assembler keyword
.PP
The keyword
DEFINED(symbol) (avrassembler.wb_expressions.html#avrassembler.wb_expressions.DEFINED_symbol)
is recognized in all contexts, it should only be recognized in
conditionals.
This prevents
DEFINED(symbol) (avrassembler.wb_expressions.html#avrassembler.wb_expressions.DEFINED_symbol)
to be used as a user symbol like a label, etc.
On the other hand, it allows for constructs like `\&.dw foo =
defined(bar)' which it shouldn't.
Note that the preprocessor and assembler have separate implementations
of
DEFINED(symbol) (avrassembler.wb_expressions.html#avrassembler.wb_expressions.DEFINED_symbol)
.
The exact behaviour of
DEFINED(symbol) (avrassembler.wb_expressions.html#avrassembler.wb_expressions.DEFINED_symbol)
currently (from 2.1.5) is:
.IP \[bu] 2
The preprocessor `defined' keyword only relates to symbols defined with
\f[C]\ \ \ \ \ \ \ \ \ \ #define\ \ \ \ \ \ \ \ \ \f[] , and correctly
does this only in preprocessor conditionals (
\f[C]\ \ \ \ \ \ \ \ \ \ #if/#elif\ \ \ \ \ \ \ \ \ \f[] ).
.IP \[bu] 2
In all remaining code, the assembler's notion of
DEFINED(symbol) (avrassembler.wb_expressions.html#avrassembler.wb_expressions.DEFINED_symbol)
is used, the correct behaviour would be to only recognize it in
assembler conditionals (
\f[C]\ \ \ \ \ \ \ \ \ \ .if/.elif\ \ \ \ \ \ \ \ \ \f[] ).
.SS Preprocessor issues
.IP \[bu] 2
The preprocessor will not detect invalid preprocessor directives inside
a false conditional.
This may lead to surprises with typos like this:
.RS 2
.IP
.nf
\f[C]
#if\ __ATmega8__\ 
//...\ 
#elseif\ __ATmega16__\ //WRONG,\ the\ correct\ directive\ is\ #elif\ 
//\ This\ will\ go\ undetected\ if\ __ATmega8__\ is\ false\ 
//...\ 
#else\ 
//\ when\ __ATmega8__\ is\ false\ this\ section\ will\ be\ assembled\ even\ if\ 
//\ __ATmega16__\ is\ true.\ 
#endif\ 
\f[]
.fi
.PP
It is debatable if this is a bug, the behaviour is consistent with the C
preprocessor.
.RE
.IP \[bu] 2
Issue #3361: The preprocessor incorrectly allows additional text after
directives, which may cause surprises, e.g., #endif #endif will be
interpreted as a single #endif directive, without any error or warning
message.
.IP \[bu] 2
Issue #4741: Assembler conditionals in preprocessor macros don't work
Use of the macro defined below will result in different syntax error
messages, depending on the value of the conditional val (true or false)
.RS 2
.IP
.nf
\f[C]
#define\ TEST\ \\
\&.IF\ val\ \\
\&.DW\ 0\ \\
\&.ELSE\ \\
\&.DW\ 1\ \\
\&.ENDIF
\f[]
.fi
.PP
The reason for this is that assembler conditionals must appear on a
separate line, and a preprocessor macro like the above is concatenated
into a single line.
.RE
