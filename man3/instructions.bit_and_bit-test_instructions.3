.\"t
.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "Bit and Bit\-test Instructions \- \- AVR Assembler" "" "" "" ""
.hy
.SH AVR Assembler Instruction mnemonics
.SS  () Bit and Bit\-test Instructions
.PP
.TS
tab(@);
l l l l l l.
T{
 \f[B]Mnemonic\f[]
T}@T{
 \f[B]Operands\f[]
T}@T{
 \f[B]Description\f[]
T}@T{
 \f[B]Operation\f[]
T}@T{
 \f[B]Flags\f[]
T}@T{
 \f[B]Cycles\f[]
T}
_
T{
.PP
LSL (avrassembler.wb_LSL.html)
T}@T{
.PP
Rd (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rd)
T}@T{
Logical shift left
T}@T{
Rd(n+1)=Rd(n), Rd(0)=0, C=Rd(7)
T}@T{
Z,C,N,V,H,S
T}@T{
1
T}
T{
.PP
LSR (avrassembler.wb_LSR.html)
T}@T{
.PP
Rd (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rd)
T}@T{
Logical shift right
T}@T{
Rd(n)=Rd(n+1), Rd(7)=0, C=Rd(0)
T}@T{
Z,C,N,V,S
T}@T{
1
T}
T{
.PP
ROL (avrassembler.wb_ROL.html)
T}@T{
.PP
Rd (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rd)
T}@T{
Rotate left through carry
T}@T{
Rd(0)=C, Rd(n+1)=Rd(n), C=Rd(7)
T}@T{
Z,C,N,V,H,S
T}@T{
1
T}
T{
.PP
OR (avrassembler.wb_OR.html)
T}@T{
.PP
Rd (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rd)
T}@T{
Rotate right through carry
T}@T{
Rd(7)=C, Rd(n)=Rd(n+1), C=Rd(0)
T}@T{
Z,C,N,V,S
T}@T{
1
T}
T{
.PP
ASR (avrassembler.wb_ASR.html)
T}@T{
.PP
Rd (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rd)
T}@T{
Arithmetic shift right
T}@T{
Rd(n)=Rd(n+1), n=0,\&...,6
T}@T{
Z,C,N,V,S
T}@T{
1
T}
T{
.PP
SWAP (avrassembler.wb_SWAP.html)
T}@T{
.PP
Rd (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rd)
T}@T{
Swap nibbles
T}@T{
Rd(3..0) = Rd(7..4), Rd(7..4) = Rd(3..0)
T}@T{
None
T}@T{
1
T}
T{
.PP
BSET (avrassembler.wb_BSET.html)
T}@T{
.PP
s (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_s)
T}@T{
Set flag
T}@T{
SREG(s) = 1
T}@T{
SREG(s)
T}@T{
1
T}
T{
.PP
BCLR (avrassembler.wb_BCLR.html)
T}@T{
.PP
s (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_s)
T}@T{
Clear flag
T}@T{
SREG(s) = 0
T}@T{
SREG(s)
T}@T{
1
T}
T{
.PP
SBI (avrassembler.wb_SBI.html)
T}@T{
.PP
P (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_P)
,
b (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_b)
T}@T{
Set bit in I/O register
T}@T{
I/O(P,b) = 1
T}@T{
None
T}@T{
2
T}
T{
.PP
CBI (avrassembler.wb_CBI.html)
T}@T{
.PP
P (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_P)
,
b (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_b)
T}@T{
Clear bit in I/O register
T}@T{
I/O(P,b) = 0
T}@T{
None
T}@T{
2
T}
T{
.PP
BST (avrassembler.wb_BST.html)
T}@T{
.PP
Rr (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rr)
,
b (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_b)
T}@T{
Bit store from register to T
T}@T{
T = Rr(b)
T}@T{
T
T}@T{
1
T}
T{
.PP
BLD (avrassembler.wb_BLD.html)
T}@T{
.PP
Rd (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rd)
,
b (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_b)
T}@T{
Bit load from register to T
T}@T{
Rd(b) = T
T}@T{
None
T}@T{
1
T}
T{
.PP
SEC (avrassembler.wb_SEC.html)
T}@T{
None
T}@T{
Set carry flag
T}@T{
C =1
T}@T{
C
T}@T{
1
T}
T{
.PP
CLC (avrassembler.wb_CLC.html)
T}@T{
None
T}@T{
Clear carry flag
T}@T{
C = 0
T}@T{
C
T}@T{
1
T}
T{
.PP
SEN (avrassembler.wb_SEN.html)
T}@T{
None
T}@T{
Set negative flag
T}@T{
N = 1
T}@T{
N
T}@T{
1
T}
T{
.PP
CLN (avrassembler.wb_CLN.html)
T}@T{
None
T}@T{
Clear negative flag
T}@T{
N = 0
T}@T{
N
T}@T{
1
T}
T{
.PP
SEZ (avrassembler.wb_SEZ.html)
T}@T{
None
T}@T{
Set zero flag
T}@T{
Z = 1
T}@T{
Z
T}@T{
1
T}
T{
.PP
CLZ (avrassembler.wb_CLZ.html)
T}@T{
None
T}@T{
Clear zero flag
T}@T{
Z = 0
T}@T{
Z
T}@T{
1
T}
T{
.PP
SEI (avrassembler.wb_SEI.html)
T}@T{
None
T}@T{
Set interrupt flag
T}@T{
I = 1
T}@T{
I
T}@T{
1
T}
T{
.PP
CLI (avrassembler.wb_CLI.html)
T}@T{
None
T}@T{
Clear interrupt flag
T}@T{
I = 0
T}@T{
I
T}@T{
1
T}
T{
.PP
SES (avrassembler.wb_SES.html)
T}@T{
None
T}@T{
Set signed flag
T}@T{
S = 1
T}@T{
S
T}@T{
1
T}
T{
.PP
CLN (avrassembler.wb_CLN.html)
T}@T{
None
T}@T{
Clear signed flag
T}@T{
S = 0
T}@T{
S
T}@T{
1
T}
T{
.PP
SEV (avrassembler.wb_SEV.html)
T}@T{
None
T}@T{
Set overflow flag
T}@T{
V = 1
T}@T{
V
T}@T{
1
T}
T{
.PP
CLV (avrassembler.wb_CLV.html)
T}@T{
None
T}@T{
Clear overflow flag
T}@T{
V = 0
T}@T{
V
T}@T{
1
T}
T{
.PP
SET (avrassembler.wb_SET.html)
T}@T{
None
T}@T{
Set T\-flag
T}@T{
T = 1
T}@T{
T
T}@T{
1
T}
T{
.PP
CLT (avrassembler.wb_CLT.html)
T}@T{
None
T}@T{
Clear T\-flag
T}@T{
T = 0
T}@T{
T
T}@T{
1
T}
T{
.PP
SEH (avrassembler.wb_SEH.html)
T}@T{
None
T}@T{
Set half carry flag
T}@T{
H = 1
T}@T{
H
T}@T{
1
T}
T{
.PP
CLH (avrassembler.wb_CLH.html)
T}@T{
None
T}@T{
Clear half carry flag
T}@T{
H = 0
T}@T{
H
T}@T{
1
T}
T{
.PP
NOP (avrassembler.wb_NOP.html)
T}@T{
None
T}@T{
No operation
T}@T{
None
T}@T{
None
T}@T{
1
T}
T{
.PP
SLEEP (avrassembler.wb_SLEEP.html)
T}@T{
None
T}@T{
Sleep
T}@T{
See instruction manual
T}@T{
None
T}@T{
1
T}
T{
.PP
WDR (avrassembler.wb_WDR.html)
T}@T{
None
T}@T{
Watchdog Reset
T}@T{
See instruction manual
T}@T{
None
T}@T{
1
T}
T{
.PP
BREAK (avrassembler.wb_BREAK.html)
T}@T{
None
T}@T{
Execution Break
T}@T{
See instruction manual
T}@T{
None
T}@T{
1
T}
.TE
.PP
The Assembler is not case sensitive.
.PP
The operands have the following forms:
.PP
 () Rd : Destination (and source) register in the register file
.PP
  () \f[B]Rr\f[] : Source register in the register file
.PP
  () \f[B]b\f[] : Constant (0\-7), can be a constant expression
.PP
  () \f[B]s\f[] : Constant (0\-7), can be a constant expression
.PP
  () \f[B]P\f[] : Constant (0\-31/63), can be a constant expression
.PP
  () \f[B]K6\f[] ; Constant (0\-63), can be a constant expression
.PP
  () \f[B]K8\f[] : Constant (0\-255), can be a constant expression
.PP
  () \f[B]k\f[] : Constant, value range depending on instruction.
Can be a constant expression
.PP
  () \f[B]q\f[] : Constant (0\-63), can be a constant expression
.PP
  () \f[B]Rdl\f[] : R24, R26, R28, R30.
For ADIW and SBIW instructions
.PP
  () \f[B]X,Y,Z\f[] : Indirect address registers (X=R27:R26, Y=R29:R28,
Z=R31:R30)
