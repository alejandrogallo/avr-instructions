.\"t
.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "Branch Instructions \- \- AVR Assembler" "" "" "" ""
.hy
.SH AVR Assembler Instruction mnemonics
.SS Branch Instructions
.PP
.TS
tab(@);
l l l l l l.
T{
 \f[B]Mnemonic\f[]
T}@T{
 \f[B]Operands\f[]
T}@T{
 \f[B]Description\f[]
T}@T{
 \f[B]Operation\f[]
T}@T{
 \f[B]Flags\f[]
T}@T{
 \f[B]Cycles\f[]
T}
_
T{
.PP
RJMP (avrassembler.wb_RJMP.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Relative Jump
T}@T{
PC = PC + k +1
T}@T{
None
T}@T{
2
T}
T{
.PP
IJMP (avrassembler.wb_IJMP.html)
T}@T{
None
T}@T{
.PP
Indirect Jump to (
X,Y,Z (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_X_Y_Z)
)
T}@T{
PC = Z
T}@T{
None
T}@T{
2
T}
T{
.PP
EIJMP (avrassembler.wb_EIJMP.html)
T}@T{
None
T}@T{
.PP
Extended Indirect Jump (
X,Y,Z (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_X_Y_Z)
)
T}@T{
STACK = PC+1, PC(15:0) = Z, PC(21:16) = EIND
T}@T{
None
T}@T{
2
T}
T{
.PP
JMP (avrassembler.wb_JMP.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Jump
T}@T{
PC = k
T}@T{
None
T}@T{
3
T}
T{
.PP
RCALL (avrassembler.wb_RCALL.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Relative Call Subroutine
T}@T{
STACK = PC+1, PC = PC + k + 1
T}@T{
None
T}@T{
3/4*
T}
T{
.PP
ICALL (avrassembler.wb_ICALL.html)
T}@T{
None
T}@T{
.PP
Indirect Call to (
X,Y,Z (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_X_Y_Z)
)
T}@T{
STACK = PC+1, PC = Z
T}@T{
None
T}@T{
3/4*
T}
T{
.PP
EICALL (avrassembler.wb_EICALL.html)
T}@T{
None
T}@T{
Extended Indirect Call to (
X,Y,Z (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_X_Y_Z)
)
T}@T{
STACK = PC+1, PC(15:0) = Z, PC(21:16) =EIND
T}@T{
None
T}@T{
4*
T}
T{
.PP
CALL (avrassembler.wb_CALL.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Call Subroutine
T}@T{
STACK = PC+2, PC = k
T}@T{
None
T}@T{
4/5*
T}
T{
.PP
RET (avrassembler.wb_RET.html)
T}@T{
None
T}@T{
Subroutine Return
T}@T{
PC = STACK
T}@T{
None
T}@T{
4/5*
T}
T{
.PP
RETI (avrassembler.wb_RETI.html)
T}@T{
None
T}@T{
Interrupt Return
T}@T{
PC = STACK
T}@T{
I
T}@T{
4/5*
T}
T{
.PP
CPSE (avrassembler.wb_CPSE.html)
T}@T{
.PP
Rd (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rd)
,
Rr (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rr)
T}@T{
Compare, Skip if equal
T}@T{
if (Rd ==Rr) PC = PC 2 or 3
T}@T{
None
T}@T{
1/2/3
T}
T{
.PP
CP (avrassembler.wb_CP.html)
T}@T{
.PP
Rd (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rd)
,
Rr (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rr)
T}@T{
Compare
T}@T{
Rd \-Rr
T}@T{
Z,C,N,V,H,S
T}@T{
1
T}
T{
.PP
CPC (avrassembler.wb_CPC.html)
T}@T{
.PP
Rd (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rd)
,
Rr (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rr)
T}@T{
Compare with Carry
T}@T{
Rd \- Rr \- C
T}@T{
Z,C,N,V,H,S
T}@T{
1
T}
T{
.PP
CPI (avrassembler.wb_CPI.html)
T}@T{
.PP
Rd (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rd)
,
K8 (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_K8)
T}@T{
Compare with Immediate
T}@T{
Rd \- K
T}@T{
Z,C,N,V,H,S
T}@T{
1
T}
T{
.PP
SBRC (avrassembler.wb_SBRC.html)
T}@T{
.PP
Rr (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rr)
,
b (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_b)
T}@T{
Skip if bit in register cleared
T}@T{
if(Rr(b)==0) PC = PC + 2 or 3
T}@T{
None
T}@T{
1/2/3
T}
T{
.PP
SBRS (avrassembler.wb_SBRS.html)
T}@T{
.PP
Rr (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_Rr)
,
b (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_b)
T}@T{
Skip if bit in register set
T}@T{
if(Rr(b)==1) PC = PC + 2 or 3
T}@T{
None
T}@T{
1/2/3
T}
T{
.PP
SBIC (avrassembler.wb_SBIC.html)
T}@T{
.PP
P (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_P)
,
b (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_b)
T}@T{
Skip if bit in I/O register cleared
T}@T{
if(I/O(P,b)==0) PC = PC + 2 or 3
T}@T{
None
T}@T{
1/2/3
T}
T{
.PP
SBIS (avrassembler.wb_SBIS.html)
T}@T{
.PP
P (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_P)
,
b (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_b)
T}@T{
Skip if bit in I/O register set
T}@T{
if(I/O(P,b)==1) PC = PC + 2 or 3
T}@T{
None
T}@T{
1/2/3
T}
T{
.PP
BRBC (avrassembler.wb_BRBC.html)
T}@T{
.PP
s (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_s)
,
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if Status flag cleared
T}@T{
if(SREG(s)==0) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRBS (avrassembler.wb_BRBS.html)
T}@T{
.PP
s (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_s)
,
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if Status flag set
T}@T{
if(SREG(s)==1) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BREQ (avrassembler.wb_BREQ.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if equal
T}@T{
if(Z==1) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRNE (avrassembler.wb_BRNE.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if not equal
T}@T{
if(Z==0) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRCS (avrassembler.wb_BRCS.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if carry set
T}@T{
if(C==1) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRCC (avrassembler.wb_BRCC.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if carry cleared
T}@T{
if(C==0) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRSH (avrassembler.wb_BRSH.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if same or higher
T}@T{
if(C==0) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRLO (avrassembler.wb_BRLO.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if lower
T}@T{
if(C==1) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRMI (avrassembler.wb_BRMI.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if minus
T}@T{
if(N==1) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRPL (avrassembler.wb_BRPL.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if plus
T}@T{
if(N==0) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRGE (avrassembler.wb_BRGE.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if greater than or equal (signed)
T}@T{
if(S==0) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRLT (avrassembler.wb_BRLT.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if less than (signed)
T}@T{
if(S==1) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRHS (avrassembler.wb_BRHS.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if half carry flag set
T}@T{
if(H==1) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRHC (avrassembler.wb_BRHC.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if half carry flag cleared
T}@T{
if(H==0) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRTS (avrassembler.wb_BRTS.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if T flag set
T}@T{
if(T==1) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRTC (avrassembler.wb_BRTC.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if T flag cleared
T}@T{
if(T==0) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRVS (avrassembler.wb_BRVS.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if overflow flag set
T}@T{
if(V==1) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRVC (avrassembler.wb_BRVC.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if overflow flag cleared
T}@T{
if(V==0) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRIE (avrassembler.wb_BRIE.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if interrupt enabled
T}@T{
if(I==1) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
T{
.PP
BRID (avrassembler.wb_BRID.html)
T}@T{
.PP
k (avrassembler.wb_instructions.Bit_and_Bit-test_Instructions.html#avrassembler.wb_k)
T}@T{
Branch if interrupt disabled
T}@T{
if(I==0) PC = PC + k + 1
T}@T{
None
T}@T{
1/2
T}
.TE
