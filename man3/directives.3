.\"t
.\" Automatically generated by Pandoc 1.16.0.2
.\"
.TH "Assembler directives \- \- AVR Assembler" "" "" "" ""
.hy
.SH AVR Assembler Assembler directives
.PP
.TS
tab(@);
l l.
T{
 \f[B]Directive\f[]
T}@T{
 \f[B]Description\f[]
T}
_
T{
.PP
BYTE (avrassembler.wb_directives.html#avrassembler.wb_directives.BYTE)
T}@T{
.PP
Reserve byte(s) to a
variable. (avrassembler.wb_directives.html#avrassembler.wb_directives.BYTE)
T}
T{
.PP
CSEG (avrassembler.wb_directives.html#avrassembler.wb_directives.CSEG)
T}@T{
.PP
Code
Segment (avrassembler.wb_directives.html#avrassembler.wb_directives.CSEG)
T}
T{
.PP
CSEGSIZE (avrassembler.wb_directives.html#avrassembler.wb_directives.CSEGSIZE)
T}@T{
.PP
Program memory
size (avrassembler.wb_directives.html#avrassembler.wb_directives.CSEGSIZE)
T}
T{
.PP
DB (avrassembler.wb_directives.html#avrassembler.wb_directives.DB)
T}@T{
.PP
Define constant
byte(s) (avrassembler.wb_directives.html#avrassembler.wb_directives.DB)
T}
T{
.PP
DEF (avrassembler.wb_directives.html#avrassembler.wb_directives.DEF)
T}@T{
Define a symbolic name on a
register (avrassembler.wb_directives.html#avrassembler.wb_directives.DEF)
T}
T{
.PP
DSEG (avrassembler.wb_directives.html#avrassembler.wb_directives.DSEG)
T}@T{
Data
Segment (avrassembler.wb_directives.html#avrassembler.wb_directives.DSEG)
T}
T{
.PP
DW (avrassembler.wb_directives.html#avrassembler.wb_directives.DW)
T}@T{
Define Constant
word(s) (avrassembler.wb_directives.html#avrassembler.wb_directives.DW)
T}
T{
.PP
ENDM,
ENDMACRO (avrassembler.wb_directives.html#avrassembler.wb_directives.ENDMACRO)
T}@T{
EndMacro (avrassembler.wb_directives.html#avrassembler.wb_directives.ENDMACRO)
T}
T{
.PP
EQU (avrassembler.wb_directives.html#avrassembler.wb_directives.EQU)
T}@T{
Set a symbol equal to an
expression (avrassembler.wb_directives.html#avrassembler.wb_directives.EQU)
T}
T{
.PP
ESEG (avrassembler.wb_directives.html#avrassembler.wb_directives.ESEG)
T}@T{
EEPROM
Segment (avrassembler.wb_directives.html#avrassembler.wb_directives.ESEG)
T}
T{
.PP
EXIT (avrassembler.wb_directives.html#avrassembler.wb_directives.EXIT)
T}@T{
Exit from
file (avrassembler.wb_directives.html#avrassembler.wb_directives.EXIT)
T}
T{
.PP
INCLUDE (avrassembler.wb_directives.html#avrassembler.wb_directives.INCLUDE)
T}@T{
Read source from another
file (avrassembler.wb_directives.html#avrassembler.wb_directives.INCLUDE)
T}
T{
.PP
LIST (avrassembler.wb_directives.html#avrassembler.wb_directives.LIST)
T}@T{
Turn listfile generation
on (avrassembler.wb_directives.html#avrassembler.wb_directives.LIST)
T}
T{
.PP
LISTMAC (avrassembler.wb_directives.html#avrassembler.wb_directives.LISTMAC)
T}@T{
Turn Macro expansion in list file
on (avrassembler.wb_directives.html#avrassembler.wb_directives.LISTMAC)
T}
T{
.PP
MACRO (avrassembler.wb_directives.html#avrassembler.wb_directives.MACRO)
T}@T{
Begin
Macro (avrassembler.wb_directives.html#avrassembler.wb_directives.MACRO)
T}
T{
.PP
NOLIST (avrassembler.wb_directives.html#avrassembler.wb_directives.NOLIST)
T}@T{
Turn listfile generation
off (avrassembler.wb_directives.html#avrassembler.wb_directives.NOLIST)
T}
T{
.PP
ORG (avrassembler.wb_directives.html#avrassembler.wb_directives.ORG)
T}@T{
Set program
origin (avrassembler.wb_directives.html#avrassembler.wb_directives.ORG)
T}
T{
.PP
SET (avrassembler.wb_directives.html#avrassembler.wb_directives.SET)
T}@T{
Set a symbol to an
expression (avrassembler.wb_directives.html#avrassembler.wb_directives.SET)
T}
T{
.PP
ELSE,ELIF (avrassembler.wb_directives.html#avrassembler.wb_directives.ELSE)
T}@T{
Conditional
assembly (avrassembler.wb_directives.html#avrassembler.wb_directives.ELSE)
T}
T{
.PP
ENDIF (avrassembler.wb_directives.html#avrassembler.wb_directives.ENDIF)
T}@T{
Conditional
assembly (avrassembler.wb_directives.html#avrassembler.wb_directives.ENDIF)
T}
T{
.PP
ERROR (avrassembler.wb_directives.html#avrassembler.wb_directives.ERROR)
T}@T{
Outputs an error
message (avrassembler.wb_directives.html#avrassembler.wb_directives.ERROR)
T}
T{
IF,IFDEF,IFNDEF (avrassembler.wb_directives.html#avrassembler.wb_directives.IFDEF)
T}@T{
Conditional
assembly (avrassembler.wb_directives.html#avrassembler.wb_directives.IFDEF)
T}
T{
.PP
MESSAGE (avrassembler.wb_directives.html#avrassembler.wb_directives.MESSAGE)
T}@T{
Outputs a message
string (avrassembler.wb_directives.html#avrassembler.wb_directives.MESSAGE)
T}
T{
.PP
DD (avrassembler.wb_directives.html#avrassembler.wb_directives.DD)
T}@T{
Define
Doubleword (avrassembler.wb_directives.html#avrassembler.wb_directives.DD)
T}
T{
.PP
DQ (avrassembler.wb_directives.html#avrassembler.wb_directives.DQ)
T}@T{
Define
Quadword (avrassembler.wb_directives.html#avrassembler.wb_directives.DQ)
T}
T{
.PP
UNDEF (avrassembler.wb_directives.html#avrassembler.wb_directives.UNDEF)
T}@T{
Undefine register
symbol (avrassembler.wb_directives.html#avrassembler.wb_directives.UNDEF)
T}
T{
.PP
WARNING (avrassembler.wb_directives.html#avrassembler.wb_directives.WARNING)
T}@T{
Outputs a warning
message (avrassembler.wb_directives.html#avrassembler.wb_directives.WARNING)
T}
T{
.PP
OVERLAP/NOOVERLAP (avrassembler.wb_directives.html#avrassembler.wb_directives.OVERLAP)
T}@T{
Set up overlapping
section (avrassembler.wb_directives.html#avrassembler.wb_directives.OVERLAP)
T}
.TE
.SS Note
.PP
Note that all directives must be preceded by a period.
.SS BYTE \- reserve bytes for a variable
.PP
The BYTE directive reserves memory resources in the SRAM or EEPROM.
In order to be able to refer to the reserved location, the BYTE
directive should be preceded by a label.
The directive takes one parameter, which is the number of bytes to
reserve.
The directive can not be used within a Code segment (see directives
ESEG (avrassembler.wb_directives.html#avrassembler.wb_directives.ESEG) ,
CSEG (avrassembler.wb_directives.html#avrassembler.wb_directives.CSEG) ,
DSEG (avrassembler.wb_directives.html#avrassembler.wb_directives.DSEG) )
.Note that a parameter must be given.
The allocated bytes are not initialized.
.PP
 \f[B]Syntax:\f[]
.PP
LABEL: .BYTE expression
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.DSEG\ 
var1:\ \ .BYTE\ 1\ ;\ reserve\ 1\ byte\ to\ var1\ 
table:\ .BYTE\ tab_size\ ;\ reserve\ tab_size\ bytes

\&.CSEG\ 
ldi\ r30,low(var1)\ ;\ Load\ Z\ register\ low\ 
ldi\ r31,high(var1)\ ;\ Load\ Z\ register\ high\ 
ld\ r1,Z\ ;\ Load\ VAR1\ into\ register\ 1
\f[]
.fi
.PP
.SS CSEG \- Code segment
.PP
The CSEG directive defines the start of a Code Segment.
An Assembler file can consist of several Code Segments, which are
concatenated into one Code Segment when assembled.
The BYTE directive can not be used within a Code Segment.
The default segment type is Code.
The Code Segments have their own location counter which is a word
counter.
The ORG directive can be used to place code and constants at specific
locations in the Program memory.
The directive does not take any parameters.
.PP
 \f[B]Syntax:\f[]
.PP
\&.CSEG
.PP
 \f[B]Example:\f[]
.PP
.IP
.nf
\f[C]
\&.DSEG\ ;\ Start\ data\ segment\ 
vartab:\ .BYTE\ 4\ ;\ Reserve\ 4\ bytes\ in\ SRAM

\&.CSEG\ ;\ Start\ code\ segment\ 
const:\ .DW\ 2\ ;\ Write\ 0x0002\ in\ prog.mem.\ 
mov\ r1,r0\ ;\ Do\ something
\f[]
.fi
.PP
.SS CSEGSIZE \- Program Memory Size
.PP
 AT94K devices have a user configurable memory partition between the AVR
Program memory and the data memory.
The program and data SRAM is divided into three blocks: 10K x 16
dedicated program SRAM, 4K x 8 dedicated data SRAM, and 6K x 16 or 12K x
8 configurable SRAM which may be swapped between program and data memory
spaces in 2K x 16 or 4K x 8 partitions.
This directive is used to specify the size of the program memory block.
.PP
 \f[B]Syntax:\f[]
.PP
\&.CSEGSIZE = 10 | 12 | 14 | 16
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.CSEGSIZE\ =\ 12\ ;\ Specifies\ the\ program\ meory\ size\ as\ 12K\ x\ 16
\f[]
.fi
.PP
.SS DB \- Define constant byte(s) in program memory and EEPROM
.PP
The DB directive reserves memory resources in the program memory or the
EEPROM memory.
In order to be able to refer to the reserved locations, the DB directive
should be preceded by a label.
The DB directive takes a list of expressions, and must contain at least
one expression.
The DB directive must be placed in a Code Segment or an EEPROM Segment.
.PP
The expression list is a sequence of expressions, delimited by commas.
Each expression must evaluate to a number between \-128 and 255.
If the expression evaluates to a negative number, the 8 bits twos
complement of the number will be placed in the program memory or EEPROM
memory location.
.PP
If the DB directive is given in a Code Segment and the expressionlist
contains more than one expression, the expressions are packed so that
two bytes are placed in each program memory word.
 \f[I]If the expressionlist contains an odd number of expressions, the
last expression will be placed in a program memory word of its own, even
if the next line in the assemby code contains a DB directive.\f[] The
unused half of the program word is set to zero.
A warning is given, in order to notify the user that an extra zero byte
is added to the .DB statement
.PP
 \f[B]Syntax:\f[]
.PP
LABEL: .DB expressionlist
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.CSEG\ 
consts:\ .DB\ 0,\ 255,\ 0b01010101,\ \-128,\ 0xaa

\&.ESEG\ 
const2:\ .DB\ 1,2,3
\f[]
.fi
.PP
.SS DEF \- Set a symbolic name on a register
.PP
The DEF directive allows the registers to be referred to through
symbols.
A defined symbol can be used in the rest of the program to refer to the
register it is assigned to.
A register can have several symbolic names attached to it.
A symbol can be redefined later in the program.
.PP
 \f[B]Syntax:\f[]
.PP
\&.DEF Symbol=Register
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.DEF\ temp=R16\ 
\&.DEF\ ior=R0

\&.CSEG\ 
ldi\ temp,0xf0\ ;\ Load\ 0xf0\ into\ temp\ register\ 
in\ ior,0x3f\ ;\ Read\ SREG\ into\ ior\ register\ 
eor\ temp,ior\ ;\ Exclusive\ or\ temp\ and\ ior
\f[]
.fi
.PP
.SS UNDEF \- Undefine a register symbolic name
.PP
'The UNDEF directive is used to undefine a symbol previously defined
with the
DEF (avrassembler.wb_directives.html#avrassembler.wb_directives.DEF)
directive.
This provides a way to obtain a simple scoping of register definitions,
to avoid warnings about register reuse.
.PP
 \f[B]Syntax:\f[]
.PP
\&.UNDEF symbol
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.DEF\ var1\ =\ R16\ 
ldi\ var1,\ 0x20\ 
\&...\ ;\ do\ something\ more\ with\ var1\ 
\&.UNDEF\ var1\ 

\&.DEF\ var2\ =\ R16\ ;\ R16\ can\ now\ be\ reused\ without\ warning.
\f[]
.fi
.PP
.SS DSEG \- Data Segment
.PP
The DSEG directive defines the start of a Data segment.
An assembler source file can consist of several data segments, which are
concatenated into a single data segment when assembled.
A data segment will normally only consist of BYTE directives (and
labels).
The Data Segments have their own location counter which is a byte
counter.
The ORG directive can be used to place the variables at specific
locations in the SRAM.
The directive does not take any parameters.
.PP
 \f[B]Syntax:\f[]
.PP
\&.DSEG
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.DSEG\ ;\ Start\ data\ segment\ 
var1:\ .BYTE\ 1\ ;\ reserve\ 1\ byte\ to\ var1\ 
table:\ .BYTE\ tab_size\ ;\ reserve\ tab_size\ bytes.

\&.CSEG\ 
ldi\ r30,low(var1)\ ;\ Load\ Z\ register\ low\ 
ldi\ r31,high(var1)\ ;\ Load\ Z\ register\ high\ 
ld\ r1,Z\ ;\ Load\ var1\ into\ register\ 1
\f[]
.fi
.PP
.SS DW \- Define constant word(s) in program memory and EEPROM
.PP
The DW directive reserves memory resources in the program memory or the
EEPROM memory.
In order to be able to refer to the reserved locations, the DW directive
should be preceded by a label.
The DW directive takes a list of expressions, and must contain at least
one expression.
The DB directive must be placed in a Code Segment or an EEPROM Segment.
.PP
The expression list is a sequence of expressions, delimited by commas.
Each expression must evaluate to a number between \-32768 and 65535.
If the expression evaluates to a negative number, the 16 bits two's
complement of the number will be placed in the program memory or EEPROM
memory location.
.PP
 \f[B]Syntax:\f[]
.PP
LABEL: .DW expressionlist
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.CSEG\ 
varlist:\ .DW\ 0,\ 0xffff,\ 0b1001110001010101,\ \-32768,\ 65535

\&.ESEG\ 
eevarlst:\ .DW\ 0,0xffff,10
\f[]
.fi
.PP
.SS DD \- Define constant doubleword(s) in program memory and EEPROM
.SS DQ \- Define constant quadword(s) in program memory and EEPROM
.PP
These directives are very similar to the
DW (avrassembler.wb_directives.html#avrassembler.wb_directives.DW)
directive, except they are used to define 32\-bit (doubleword) and
64\-bit (quadword) respectively.
The data layout in memory is strictly little\-endian.
.PP
 \f[B]Syntax:\f[]
.PP
LABEL: .DD expressionlist
.PP
LABEL: .DQ expressionlist
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.CSEG\ 
varlist:\ .DD\ 0,\ 0xfadebabe,\ \-2147483648,\ 1\ <<\ 30

\&.ESEG\ 
eevarlst:\ .DQ\ 0,0xfadebabedeadbeef,\ 1\ <<\ 62
\f[]
.fi
.PP
.SS >ELIF,ELSE \- conditional assembly
.PP
\&.ELIF will include code until the corresponding ENDIF of the next ELIF
at the same level if the expression is true, and both the initial .IF
clause and all following .ELIF clauses are false.
.PP
\&.ELSE will include code until the corresponding .ENDIF if the
initial.IF clause and all .ELIF clauses (if any) all are false.
.PP
 \f[B]Syntax:\f[]
.PP
\&.ELIF<expression>
.PP
\&.ELSE
.PP
\&.IFDEF <symbol> |.IFNDEF <symbol>
.PP
\&...
.PP
\&.ELSE | .ELIF<expression>
.PP
\&...
.PP
\&.ENDIF
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.IFDEF\ DEBUG\ 
\&.MESSAGE\ "Debugging.."\ 
\&.ELSE\ 
\&.MESSAGE\ "Release.."\ 
\&.ENDIF
\f[]
.fi
.PP
.SS ENDIF \- conditional assembly
.PP
Conditional assembly includes a set of commands at assembly time.
The ENDIF directive defines the end for the conditional IF or IFDEF or
IFNDEF directives.
.PP
Conditionals (.IF\&...ELIF\&...ELSE\&...ENDIF blocks) may be nested, but
all conditionals must be terminated at the end of file (conditionals may
not span multiple files).
.PP
 \f[B]Syntax:\f[]
.PP
\&.ENDIF
.PP
\&.IFDEF <symbol> |.IFNDEF <symbol>
.PP
\&...
.PP
\&.ELSE | .ELIF<expression>
.PP
\&...
.PP
\&.ENDIF
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.IFNDEF\ DEBUG\ 
\&.MESSAGE\ "Release.."\ 
\&.ELSE\ 
\&.MESSAGE\ "Debugging.."\ 
\&.ENDIF
\f[]
.fi
.PP
.SS ENDM, ENDMACRO \- End macro
.PP
The ENDMACRO directive defines the end of a macro definition.
The directive does not take any parameters.
See the MACRO directive for more information on defining macros.
ENDM is an alternative form, fully equivalent with ENDMACRO.
.PP
 \f[B]Syntax:\f[]
.PP
\&.ENDMACRO
.PP
\&.ENDM
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.MACRO\ SUBI16\ ;\ Start\ macro\ definition\ 
subi\ r16,low(\@0)\ ;\ Subtract\ low\ byte\ 
sbci\ r17,high(\@0)\ ;\ Subtract\ high\ byte\ 
\&.ENDMACRO
\f[]
.fi
.PP
.SS EQU \- Set a symbol equal to an expression
.PP
The EQU directive assigns a value to a label.
This label can then be used in later expressions.
A label assigned to a value by the EQU directive is a constant and can
not be changed or redefined.
.PP
 \f[B]Syntax:\f[]
.PP
\&.EQU label = expression
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.EQU\ io_offset\ =\ 0x23\ 
\&.EQU\ porta\ =\ io_offset\ +\ 2.CSEG\ ;\ Start\ code\ segment\ 
clr\ r2\ ;\ Clear\ register\ 2\ 
out\ porta,r2\ ;\ Write\ to\ Port\ A
\f[]
.fi
.PP
.SS ERROR \- Outputs an error message string
.PP
The ERROR directive outputs a string and halts the assembling.
May be used in conditional assembly.
.PP
 \f[B]Syntax:\f[]
.PP
\&.ERROR \[lq]<string>\[rq]
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.IFDEF\ TOBEDONE\ 
\&.ERROR\ "Still\ stuff\ to\ be\ done.."\ 
\&.ENDIF
\f[]
.fi
.PP
.SS WARNING \- Outputs a warning message string
.PP
The .WARNING directive outputs a warning string, but unlike the .ERROR
directive does not halt assembling.
May be used in conditional assembly.
.PP
 \f[B]Syntax:\f[]
.PP
\&.WARNING\[lq]<string>\[rq]
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.IFDEF\ EXPERIMENTAL_FEATURE\ 
\&.WARNING\ "This\ is\ not\ properly\ tested,\ use\ at\ own\ risk."\ 
\&.ENDIF
\f[]
.fi
.PP
.SS ESEG \- EEPROM Segment
.PP
The ESEG directive defines the start of an EEPROM segment.
An assembler source file can consist of several EEPROM segments, which
are concatenated into a single EEPROM segment when assembled.
An EEPROM segment will normally only consist of DB and DW directives
(and labels).
The EEPROM segments have their own location counter which is a byte
counter.
The ORG directive can be used to place the variables at specific
locations in the EEPROM.
The directive does not take any parameters.
.PP
 \f[B]Syntax:\f[]
.PP
\&.ESEG
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.DSEG\ ;\ Start\ data\ segment\ 
var1:\ .BYTE\ 1\ ;\ reserve\ 1\ byte\ to\ var1\ 
table:\ .BYTE\ tab_size\ ;\ reserve\ tab_size\ bytes.

\&.ESEG\ 
eevar1:\ .DW\ 0xffff\ ;\ initialize\ 1\ word\ in\ EEPROM
\f[]
.fi
.PP
.SS EXIT \- Exit this file
.PP
The EXIT directive tells the Assembler to stop assembling the file.
Normally, the Assembler runs until end of file (EOF).
If an EXIT directive appears in an included file, the Assembler
continues from the line following the INCLUDE directive in the file
containing the INCLUDE directive.
.PP
 \f[B]Syntax:\f[]
.PP
\&.EXIT
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.EXIT\ ;\ Exit\ this\ file
\f[]
.fi
.PP
.SS INCLUDE \- Include another file
.PP
The INCLUDE directive tells the Assembler to start reading from a
specified file.
The Assembler then assembles the specified file until end of file (EOF)
or an EXIT directive is encountered.
An included file may itself contain INCLUDE directives.
The difference between the two forms is that the first searches the
current directory first, the second does not.
.PP
 \f[B]Syntax:\f[]
.PP
\&.INCLUDE \[lq]filename\[rq]
.PP
\&.INCLUDE <filename>
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
;\ iodefs.asm:\ 
\&.EQU\ sreg\ =\ 0x3f\ ;\ Status\ register\ 
\&.EQU\ sphigh\ =\ 0x3e\ ;\ Stack\ pointer\ high\ 
\&.EQU\ splow\ =\ 0x3d\ ;\ Stack\ pointer\ low

;\ incdemo.asm\ 
\&.INCLUDE\ iodefs.asm\ ;\ Include\ I/O\ definitions\ 
in\ r0,sreg\ ;\ Read\ status\ register
\f[]
.fi
.PP
.SS IF,IFDEF,IFNDEF \- conditional assembly
.PP
Conditional assembly includes a set of commands at assembly time.
The IFDEF directive will include code till the corresponding ELSE
directive if <symbol> is defined.
The symbol must be defined with the EQU or SET directive.
(Will not work with the DEF directive) The IF directive will include
code if <expression> is evaluated different from 0.
Valid till the corresponding ELSE or ENDIF directive.
.PP
Up to 5 levels of nesting is possible.
.PP
 \f[B]Syntax:\f[]
.PP
\&.IFDEF <symbol>
.PP
\&.IFNDEF <symbol>
.PP
\&.IF <expression>
.PP
\&.IFDEF <symbol> |.IFNDEF <symbol>
.PP
\&...
.PP
\&.ELSE | .ELIF<expression>
.PP
\&...
.PP
\&.ENDIF
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.MACRO\ SET_BAT\ 
\&.IF\ \@0>0x3F\ 
\&.MESSAGE\ "Address\ larger\ than\ 0x3f"\ 
lds\ \@2,\ \@0\ 
sbr\ \@2,\ (1<<\@1)\ 
sts\ \@0,\ \@2\ 
\&.ELSE\ 
\&.MESSAGE\ "Address\ less\ or\ equal\ 0x3f"\ 
\&.ENDIF\ 
\&.ENDMACRO
\f[]
.fi
.PP
.SS LIST \- Turn the listfile generation on
.PP
The LIST directive tells the Assembler to turn listfile generation on.
The Assembler generates a listfile which is a combination of assembly
source code, addresses and opcodes.
Listfile generation is turned on by default.
The directive can also be used together with the NOLIST directive in
order to only generate listfile of selected parts of an assembly source
file.
.PP
 \f[B]Syntax:\f[]
.PP
\&.LIST
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.NOLIST\ ;\ Disable\ listfile\ generation\ 
\&.INCLUDE\ "macro.inc"\ ;\ The\ included\ files\ will\ not\ 
\&.INCLUDE\ "const.def"\ ;\ be\ shown\ in\ the\ listfile\ 
\&.LIST\ ;\ Reenable\ listfile\ generation
\f[]
.fi
.PP
.SS LISTMAC \- Turn macro expansion on
.PP
The LISTMAC directive tells the Assembler that when a macro is called,
the expansion of the macro is to be shown on the listfile generated by
the Assembler.
The default is that only the macro\-call with parameters is shown in the
listfile.
.PP
 \f[B]Syntax:\f[]
.PP
\&.LISTMAC
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.MACRO\ MACX\ ;\ Define\ an\ example\ macro\ 
add\ r0,\@0\ ;\ Do\ something\ 
eor\ r1,\@1\ ;\ Do\ something\ 
\&.ENDMACRO\ ;\ End\ macro\ definition

\&.LISTMAC\ ;\ Enable\ macro\ expansion\ 

MACX\ r2,r1\ ;\ Call\ macro,\ show\ expansion
\f[]
.fi
.PP
.SS MACRO \- Begin macro
.PP
The MACRO directive tells the Assembler that this is the start of a
Macro.
The MACRO directive takes the Macro name as parameter.
When the name of the Macro is written later in the program, the Macro
definition is expanded at the place it was used.
A Macro can take up to 10 parameters.
These parameters are referred to as \@0\-\@9 within the Macro
definition.
When issuing a Macro call, the parameters are given as a comma separated
list.
The Macro definition is terminated by an ENDMACRO directive.
.PP
By default, only the call to the Macro is shown on the listfile
generated by the Assembler.
In order to include the macro expansion in the listfile, a LISTMAC
directive must be used.
A macro is marked with a + in the opcode field of the listfile.
.PP
 \f[B]Syntax:\f[]
.PP
\&.MACRO macroname
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.MACRO\ SUBI16\ ;\ Start\ macro\ definition\ 
subi\ \@1,low(\@0)\ ;\ Subtract\ low\ byte\ 
sbci\ \@2,high(\@0)\ ;\ Subtract\ high\ byte\ 
\&.ENDMACRO\ ;\ End\ macro\ definition

\&.CSEG\ ;\ Start\ code\ segment\ 
SUBI16\ 0x1234,r16,r17\ ;\ Sub.0x1234\ from\ r17:r16
\f[]
.fi
.PP
.SS MESSAGE \- Output a message string
.PP
The MESSAGE directive outputs a string.
Useful in conditional assembly.
.PP
 \f[B]Syntax:\f[]
.PP
\&.MESSAGE \[lq]<string>\[rq]
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.IFDEF\ DEBUG
\&.MESSAGE\ "Debug\ mode"
\&.ENDIF
\f[]
.fi
.PP
.SS NOLIST \- Turn listfile generation off
.PP
The NOLIST directive tells the Assembler to turn listfile generation
off.
The Assembler normally generates a listfile which is a combination of
assembly source code, addresses and opcodes.
Listfile generation is turned on by default, but can be disabled by
using this directive.
The directive can also be used together with the LIST directive in order
to only generate listfile of selected parts of an assembly source file.
.PP
 \f[B]Syntax:\f[]
.PP
\&.NOLIST
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.NOLIST\ ;\ Disable\ listfile\ generation\ 
\&.INCLUDE\ "macro.inc"\ ;\ The\ included\ files\ will\ not\ 
\&.INCLUDE\ "const.def"\ ;\ be\ shown\ in\ the\ listfile\ 
\&.LIST\ ;\ Reenable\ listfile\ generation
\f[]
.fi
.PP
.SS ORG \- Set program origin
.PP
The ORG directive sets the location counter to an absolute value.
The value to set is given as a parameter.
If an ORG directive is given within a Data Segment, then it is the SRAM
location counter which is set, if the directive is given within a Code
Segment, then it is the Program memory counter which is set and if the
directive is given within an EEPROM Segment, it is the EEPROM location
counter which is set.
.PP
The default values of the Code and the EEPROM location counters are
zero, and the default value of the SRAM location counter is the address
immediately following the end of I/O address space (0x60 for devices
without extended I/O, 0x100 or more for devices with extended I/O) when
the assembling is started.
Note that the SRAM and EEPROM location counters count bytes whereas the
Program memory location counter counts words.
Also note that some devices lack SRAM and/or EEPROM.
.PP
 \f[B]Syntax:\f[]
.PP
\&.ORG expression
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.DSEG\ ;\ Start\ data\ segment
\&.ORG\ 0x120;\ Set\ SRAM\ address\ to\ hex\ 120\ 
variable:\ .BYTE\ 1\ ;\ Reserve\ a\ byte\ at\ SRAM\ adr.\ 0x120

\&.CSEG\ 
\&.ORG\ 0x10\ ;\ Set\ Program\ Counter\ to\ hex\ 10\ 
mov\ r0,r1\ ;\ Do\ something
\f[]
.fi
.PP
.SS SET \- Set a symbol equal to an expression
.PP
The SET directive assigns a value to a label.
This label can then be used in later expressions.
Unlike the
EQU (avrassembler.wb_directives.html#avrassembler.wb_directives.EQU)
directive, a label assigned to a value by the SET directive can be
changed (redefined) later in the program.
.PP
 \f[B]Syntax:\f[]
.PP
\&.SET label = expression
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.SET\ FOO\ =\ 0x114;\ set\ FOO\ to\ point\ to\ an\ SRAM\ location\ 
lds\ r0,\ FOO;\ load\ location\ into\ r0\ 
\&.SET\ FOO\ =\ FOO\ +\ 1\ ;\ increment\ (redefine)\ FOO.\ This\ would\ be\ illegal\ if\ using\ .EQU\ 
lds\ r1,\ FOO\ ;\ load\ next\ location\ into\ r1
\f[]
.fi
.PP
.SS OVERLAP/NOOVERLAP \- Set up overlapping section
.PP
Introduced in AVRASM 2.1.
These directives are for projects with special needs and should normally
not be used.
.PP
These directives only affect the currently active segment (
CSEG (avrassembler.wb_directives.html#avrassembler.wb_directives.CSEG) /
DSEG (avrassembler.wb_directives.html#avrassembler.wb_directives.DSEG) /
ESEG (avrassembler.wb_directives.html#avrassembler.wb_directives.ESEG)
).
.PP
The .overlap/nooverlap directives mark a section that will be allowed to
overlap code/data with code/data defined elsewhere, without any error or
warning messages being generated.
This is totally independent of what is set using the
#pragma (avrassembler.wb_preprocessor.pragma.html) directives.
The overlap\-allowed attribute will stay in effect across .org
directives, but will not follow across .cseg/.eseg/.dseg directives
(each segment marked separately).
.PP
 \f[B]Syntax:\f[]
.PP
\&.OVERLAP
.PP
\&.NOOVERLAP
.PP
 \f[B]Example:\f[]
.IP
.nf
\f[C]
\&.overlap\ 
\&.org\ 0\ ;\ section\ #1\ 
rjmp\ default\ 
\&.nooverlap\ 
\&.org\ 0\ ;\ section\ #2\ 
rjmp\ RESET\ ;\ No\ error\ given\ here\ 
\&.org\ 0\ ;\ section\ #3\ 
rjmp\ RESET\ ;\ Error\ here\ because\ overlap\ with\ #2
\f[]
.fi
.PP
.PP
The typical use of this is to set up some form of default code or data
that may or may not later be modified by overlapping code or data,
without having to disable assembler overlap detection altogether.
